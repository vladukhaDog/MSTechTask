# Архитектура

Использовал базовый паттерн MVVM для экранов (в основном для логико нагруженного экрана пейвола),
В основе всего проекта лежит некий паттерн Coordinator, так как он идеально подходит под базовое тз - сменяемые три экрана.

# Структура проекта
Имеем папку со всем основными экранами `AppStateViews`:
1. `OnboardingView`
2. `MainAppView`
3. `PaywallView` (Папка с экраном и вью моделью, DI протоколом)

Дальше имеем папку `Services`, в которой находится сервис Координатора и сервис сохранения данных
1. `AppFlowController`
2. `UserDefaultsService`

`RootFlowView` Лежит в базе проекта, который отвечает за визуальное переключение между экранами и читает `AppFlowController`, 
больше не придумал куда его лучше впихать на этом этапе, возможно стоило совместить в папку с координатором


# Что бы улучшил при большем времени.

## Di на сервис сохранения

Первым делом обязательно бы разделил логику сохранения статуса онбординга и статуса подписки в два разных протокола и 
передавал бы им Сервис сохранения (`UserDefaultsService` в данном случае) где нибудь повыше, скорее всего из главного AppView.
Так можно было бы проще тестировать этот класс, тестировать логику экранов передавая им Мок сервис с сохраненными данными

## Di на сервис координатора и сервис отправки эвентов

Такой же смысл - чтобы передавать в экраны EventSender инжектом, а сейчас это вшитый Enum со статик функцией - сложней тестировать в Превью логику отправки эвента

## Дальнейшая архитектура

В дальнейшем, в зависимости от ТЗ самого приложения, чуть более корректно раскидал бы файлы, сделал мы правильный сервис старта приложения, в котором бы контролировалось какие стейты 
существуют в приложении чтобы регистрировать их на AppFlowController Events Listener, соотвтествено для более простого расширения состояний

## Расширение стейтов

Сейчас используется Switch/big if для отображения экранов в `RootFlowView`, в будущем я бы сделал фабрику под это дело, чтобы существующие стейты и то, какой должен выдавать экран добавлялись
Просто созданием соответствующей структурой под протоколом FlowState и там же описывал создание экрана, но в данный момент с вечера позабывалл идеальный вариант для фабрики View, а нейронка
выдавала нормально только абстрактные способы (хоть и верные). Для выполнения этого пункта нужно чуть перечитать документацию/гайды, чтобы максимально правильно по 
производительности и вызовам обновления экрана создать фабрику вьюшек.

## Сервис алертов

Базовая в принципе логика - иметь свой Алерт сервис, который отображает на экране какие-то алерты об удачной или неудачной работе, но на его проектирование нужно чуть чуть выткнуть времени, 
особенно на то, каким способом оверлеить алерты:
1. Вытягивать верхний window и отображать на нем через UIHostingViewController
2. Отображать через .overlay на рут экране максимально высоко в структуре


В целом есть еще моменты, которые можно было бы сделать чуть по другому, но это уже зависит от спецификаций основного приложения, например если в приложении 
будет большая навигация - можно решить использовать ли для навигации и контроля стейтов один координатор, либо разделить логику
